================================================================================
LOOMI RECIPE AGENT - iOS APP INTEGRATION GUIDE
================================================================================
Two-Endpoint Microservices Architecture for Optimal User Experience
================================================================================

OVERVIEW
========
This system separates conversation intelligence from data delivery, enabling:
- Instant conversational feedback to users (1-2 seconds)
- Progressive loading of rich recipe data
- Native iOS UI formatting and control
- Scalable, cache-friendly architecture

================================================================================
API ARCHITECTURE
================================================================================

ENDPOINT 1: Agent Decision Service (Lightning Fast)
--------------------------------------------------
Purpose: Get conversational response + recipe selections from AI agent
URL: POST /agent/find-recipes
Typical Response Time: 1-2 seconds

Request:
{
  "query": "gluten-free vegan cheesecake with 20g protein",
  "target_count": 4,
  "session_id": "user_session_123" // For maintaining conversation context
}

Response:
{
  "response": "Found 2 perfect matches for your gluten-free vegan cheesecake! Both have great protein content. I also found 2 close alternatives that are vegan but use regular flour.",
  "selected_recipe_ids": ["session_recipe_003", "session_recipe_007", "session_recipe_001", "session_recipe_012"],
  "agent_metadata": {
    "search_time": "4.7s",
    "total_recipes_found": 8,
    "constraint_satisfaction": "partial",
    "follow_up_available": true
  }
}

ENDPOINT 2: Recipe Data Service (Rich Content)
----------------------------------------------
Purpose: Get complete recipe data for UI rendering
URL: POST /recipes/by-ids  
Typical Response Time: 0.1-0.3 seconds (data lookup only)

Request:
{
  "recipe_ids": ["session_recipe_003", "session_recipe_007"],
  "session_id": "user_session_123",
  "fields_requested": ["ingredients", "instructions", "nutrition", "images"] // Optional filtering
}

Response:
{
  "recipes": [
    {
      "id": "session_recipe_003",
      "title": "Perfect Vegan Cheesecake",
      "ingredients": [...],
      "instructions": [...],
      "nutrition": [...],
      "images": {...},
      "metadata": {...}
    }
  ]
}

================================================================================
iOS INTEGRATION WORKFLOW
================================================================================

RECOMMENDED USER EXPERIENCE FLOW:
----------------------------------

1. USER TYPES QUERY
   â””â”€â”€ Show typing indicator, prepare for instant feedback

2. AGENT DECISION CALL (Immediate)
   â”œâ”€â”€ Make POST /agent/find-recipes
   â”œâ”€â”€ Show agent response instantly (1-2s)
   â”œâ”€â”€ Display "Found X recipes! Loading details..." with animation
   â””â”€â”€ Parse recipe IDs for next call

3. RECIPE DATA FETCH (Progressive)
   â”œâ”€â”€ Make POST /recipes/by-ids with selected IDs
   â”œâ”€â”€ Stream in recipe cards as data arrives
   â”œâ”€â”€ Show rich native iOS UI formatting
   â””â”€â”€ Enable user interaction (save, share, cook)

4. FOLLOW-UP CONVERSATIONS
   â”œâ”€â”€ Use same session_id to maintain context
   â”œâ”€â”€ Agent remembers previous searches and constraints
   â””â”€â”€ Can reference previously found recipes

SWIFT IMPLEMENTATION PATTERN:
-----------------------------

```swift
class RecipeAgentService {
    func findRecipes(query: String, targetCount: Int = 4) async throws -> RecipeSearchResult {
        // Phase 1: Get agent decision (instant)
        let decision = try await agentAPI.findRecipes(
            query: query, 
            targetCount: targetCount,
            sessionId: currentSessionId
        )
        
        // Show agent response immediately
        DispatchQueue.main.async {
            self.showAgentResponse(decision.response)
            self.showLoadingAnimation()
        }
        
        // Phase 2: Get recipe data (progressive)
        let recipes = try await recipeAPI.getRecipesByIds(
            ids: decision.selectedRecipeIds,
            sessionId: currentSessionId
        )
        
        // Display rich recipe cards
        DispatchQueue.main.async {
            self.hideLoadingAnimation()
            self.displayRecipeCards(recipes)
        }
        
        return RecipeSearchResult(decision: decision, recipes: recipes)
    }
}
```

================================================================================
ARCHITECTURAL BENEFITS
================================================================================

PERFORMANCE ADVANTAGES:
-----------------------
- Immediate conversational feedback (no waiting for data processing)
- Progressive content loading (perceived performance improvement)
- Reduced agent processing time (96% faster agent reasoning)
- Cacheable recipe data (faster subsequent requests)

SCALABILITY BENEFITS:
--------------------
- Agent service focuses purely on intelligence
- Recipe data service can be optimized independently
- Multiple apps can share recipe data endpoint
- Easy to add new endpoints (nutritional analysis, shopping lists, etc.)

USER EXPERIENCE WINS:
--------------------
- Instant feedback creates responsive feel
- Loading animations keep users engaged
- Native iOS formatting provides beautiful presentation
- Progressive disclosure of recipe complexity

DEVELOPMENT BENEFITS:
--------------------
- Clear separation of concerns
- Easier testing (mock recipe data vs agent decisions)
- Independent deployment and scaling
- Better error isolation

================================================================================
ERROR HANDLING STRATEGY
================================================================================

ENDPOINT 1 ERRORS (Agent Decision):
-----------------------------------
- Network timeout â†’ Show "Taking longer than expected, still searching..."
- No recipes found â†’ Agent explains why and suggests alternatives
- Constraint impossible â†’ Agent suggests relaxed constraints
- Session expired â†’ Create new session transparently

ENDPOINT 2 ERRORS (Recipe Data):
--------------------------------
- Recipe IDs not found â†’ Show placeholder cards with "Recipe unavailable"
- Partial data missing â†’ Display what's available, note missing information
- Network issues â†’ Retry with exponential backoff
- Session data cleared â†’ Re-run agent search if needed

GRACEFUL DEGRADATION:
--------------------
- If recipe endpoint fails, use agent's conversational response as primary value
- Cache recipe data locally for offline viewing
- Provide manual retry options for failed recipe loads

================================================================================
CACHING AND OPTIMIZATION STRATEGY
================================================================================

AGENT DECISION CACHING:
-----------------------
- Cache based on query + constraint hash (similar queries reuse results)
- Short TTL (5-10 minutes) since food preferences change
- Session-aware caching (remember user context)

RECIPE DATA CACHING:
-------------------
- Long TTL (24+ hours) since recipe data is stable
- Cache by recipe ID (shareable across users)
- Progressive cache warming (pre-fetch popular recipes)

iOS APP CACHING:
----------------
- Cache agent responses for recent searches
- Persist favorite recipes locally
- Cache recipe images for offline viewing

================================================================================
SESSION MANAGEMENT
================================================================================

SESSION LIFECYCLE:
-----------------
- Create session ID when user starts recipe search
- Maintain session across multiple queries in same conversation
- Session stores: user intent, found recipes, conversation history
- Auto-expire after inactivity period

CONVERSATION CONTINUITY:
-----------------------
- "Find me more like recipe #2" â†’ Agent knows which recipe from session
- "Make it gluten-free" â†’ Agent applies constraint to existing search
- "Something quicker" â†’ Agent adjusts based on conversation context

SESSION MEMORY BENEFITS:
-----------------------
- Cross-reference recipes from previous searches
- Learn user preferences within conversation
- Avoid showing duplicate recipes
- Enable intelligent follow-ups

================================================================================
IMPLEMENTATION CHECKLIST
================================================================================

RAILWAY API SETUP:
------------------
â–¡ Create /agent/find-recipes endpoint (returns response + IDs)
â–¡ Create /recipes/by-ids endpoint (returns full recipe data)
â–¡ Implement session management (in-memory or Redis)
â–¡ Add comprehensive error handling
â–¡ Set up CORS for iOS app domain
â–¡ Configure rate limiting and authentication

iOS APP INTEGRATION:
-------------------
â–¡ Create AgentService for decision endpoint calls
â–¡ Create RecipeService for data endpoint calls  
â–¡ Implement progressive loading UI patterns
â–¡ Add loading animations and state management
â–¡ Create native recipe card UI components
â–¡ Implement offline caching strategy
â–¡ Add error handling and retry logic

TESTING STRATEGY:
----------------
â–¡ Test agent decisions across various query types
â–¡ Test recipe data retrieval reliability
â–¡ Test session continuity across multiple searches
â–¡ Test offline scenarios and error recovery
â–¡ Test performance under various network conditions

================================================================================
ADVANCED FEATURES (Future Enhancements)
================================================================================

POTENTIAL ADDITIONAL ENDPOINTS:
------------------------------
- POST /recipes/nutritional-analysis (detailed nutrition breakdown)
- POST /recipes/shopping-list (generate grocery list from recipe IDs)
- POST /recipes/cooking-timer (step-by-step cooking guidance)
- POST /agent/follow-up (continue conversation with additional constraints)

USER PERSONALIZATION:
--------------------
- Store user dietary preferences in session
- Learn from recipe selections and feedback
- Suggest personalized recipe modifications
- Remember successful constraint combinations

REAL-TIME FEATURES:
------------------
- WebSocket connection for real-time search progress
- Streaming recipe data as it becomes available
- Live cooking assistance with timer integration
- Social features (share recipes, rate experiences)

================================================================================
END OF INTEGRATION GUIDE
================================================================================

This architecture positions your iOS app for excellent user experience while 
maintaining the intelligent recipe discovery capabilities you've built. The 
separation of concerns enables both immediate responsiveness and rich data 
presentation through native iOS controls.

Ready to implement the two-endpoint system and begin iOS integration! ðŸš€